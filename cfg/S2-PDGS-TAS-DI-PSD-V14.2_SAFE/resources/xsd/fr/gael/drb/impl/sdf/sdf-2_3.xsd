<!--
   Sentinel-SAFE - Sentinel Format
   Copyright (C) 2011 European Space Agency (ESA)
   Copyright (C) 2011 Consultant
   GNU Lesser General Public License (LGPL)

   This file is part of Sentinel-SAFE

   Sentinel-SAFE is free software: you can redistribute it and/or modify
   it under the terms of the GNU Lesser General Public License as published by
   the Free Software Foundation, either version 3 of the License, or
   (at your option) any later version.

   Sentinel-SAFE is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU Lesser General Public License for more details.

   You should have received a copy of the GNU Lesser General Public License
   along with this program.  If not, see <http://www.gnu.org/licenses/>.
-->

<xsd:schema xmlns="http://www.gael.fr/2004/12/drb/sdf"
            xmlns:sdf="http://www.gael.fr/2004/12/drb/sdf"
            xmlns:xsd="http://www.w3.org/2001/XMLSchema"
            targetNamespace="http://www.gael.fr/2004/12/drb/sdf">

   <xsd:annotation>
     <xsd:documentation xml:lang="en">
       SDF Simple and Complex Types.
       A data file is usually defined as a set of adjacent blocks with
       various lengths. A Structured Data File is a file containing ASCII
       or BINARY data which can be described as a hierarchy of data blocks.
       These blocks are organised in a "tree model" as a file system does
       with directories, sub-directories and files.
     </xsd:documentation>
     <xsd:documentation xml:lang="en">
       SDF has been designed to use XML-Schema and create additional
       namespaces in order to describe the data from both the logical and
       the physical parts.
     </xsd:documentation>
   </xsd:annotation>


   <xsd:element name="block" type="sdf:block">
     <xsd:annotation>
       <xsd:documentation xml:lang="en">
         For all elements and types a block description node can be added to
         the appinfo node. This is the mandatory information for the physical
         description.
       </xsd:documentation>
     </xsd:annotation>
   </xsd:element>

   <xsd:element name="view" type="sdf:view">
     <xsd:annotation>
       <xsd:documentation xml:lang="en">
         Defines virtual element that is computed either from an XQuery script
         or a fixed string value.
       </xsd:documentation>
     </xsd:annotation>
   </xsd:element>


   <!-- Block definition -->

   <xsd:complexType name="block">
     <xsd:annotation>
       <xsd:documentation xml:lang="en">
         For all elements and types a block description node can be added to
         the appinfo node. This is the mandatory information for the physical
         description.
       </xsd:documentation>
     </xsd:annotation>
     <xsd:choice minOccurs="0" maxOccurs="unbounded">
       <xsd:element name="occurrence" type="sdf:occurrence"
                    default="unbounded">
         <xsd:annotation>
           <xsd:documentation xml:lang="en">
            Purpose of this node is to set the occurrence count of the
            element in the Structured Data File. This descriptor is not
            mandatory and the default value is set to 1 if omitted. The
            Occurrence count of an element can be fixed for all datafile
            using this schema or can depend on the data file instance.
            Therefore you can use this descriptor in two different ways : By
            setting a fixed value or setting a query to process with the file
            instance.
           </xsd:documentation>
         </xsd:annotation>
       </xsd:element>
       <xsd:element name="length" type="sdf:length"
                    default="unbounded">
         <xsd:annotation>
           <xsd:documentation xml:lang="en">
            This node is used to set the length of an element. It is
            mandatory for the "leaves" elements because it sets the number of
            bytes to be read to access the data in the file. For complex
            elements and types, it is not recommended to set the length
            (unless you want to force the value) because it will result from
            the sum of all child lengths, paddings, etc.  Length value can be
            defined in bytes or in bits. A "unit" attribute can be added to
            set "byte" or "bit" unit. If the "unit" attribute is ommited, the
            "byte" unit is set by default. In case of "bit" unit the length
            cannot be longer than 32 in this version. As the occurrence count
            the length can be set to a fixed value or using query.
           </xsd:documentation>
         </xsd:annotation>
       </xsd:element>
       <xsd:element name="offset" type="sdf:offset"
                    default="0">
         <xsd:annotation>
           <xsd:documentation xml:lang="en">
            Purpose of this node is to set the offset of an element.
            This means a shift between the last
            byte of the last occurrence of the previous element or the parent
            element and the first
            byte of the current one (case of relative offset).
            In most cases, an element is following
            its previous sibling without any gap therefore no relative offset
            is needed. If the "sdf:offset" node is omitted, the value is set to
            0 by default.
            Note: In order to read the data at the right offset in the file,
            the absolute offset is computed from previous element structures
            such as occurrence counts, lengths and relative offsets.
            Note: Offset value can be defined in bytes or in bits. A "unit"
            attribute can be added to set "byte" or "bit" unit. If the "unit"
            attribute is ommited, the "byte" unit is set by default.
           </xsd:documentation>
         </xsd:annotation>
       </xsd:element>
       <xsd:element name="padding" type="sdf:padding">
         <xsd:annotation>
           <xsd:documentation xml:lang="en">
            This node defines a gap (offset) before or after an element.
            The length of this gap is express as a xsd:nonNegativeInteger (in
            number of bytes).
            Two types are available: the "header" padding and the "footer"
            padding. They can be set together or only
            one of them.
            The padding has ASCII or Binary encoding:
            # "content" - fills the padding with a string value
            # "code"    - fills the padding with a single byte value
            These two attributes can not be present at the same time.
            If the "sdf:padding" node is omitted the value is set
            to 0 by default.
           </xsd:documentation>
         </xsd:annotation>
       </xsd:element>
       <xsd:element name="encoding" type="sdf:encoding"
                    default="BINARY">
         <xsd:annotation>
           <xsd:documentation xml:lang="en">
            In a logical representation the encoding is not needed but in a
            physical representation you need to know how to extract the data
            from the file. Therefore this node is used to set the encoding
            method of the element. If the "sdf:encoding" node is omitted the
            encoding is inherited from the parent. The root element has a
            BINARY encoding by default.
            Possible values are: "ASCII", "BINARY", "EBCDIC".
            Warning: the "EBCDIC" is only supported in reading mode!
            Note: Encoding method is also important to get values from numeric
            elements. In case of float a BINARY encoding means the IEEE-754
            representation is used to extract the value.
           </xsd:documentation>
         </xsd:annotation>
       </xsd:element>
       <xsd:element name="numericFormat" type="sdf:numericFormat">
         <xsd:annotation>
           <xsd:documentation xml:lang="en">
            Purpose of the sdf:numericFormat node is to set the lexical
            representation of a numeric value. It controls the following
            features:
             # integer digits
             # fraction digits
             # exponent digits
             # prefix
             # suffix
            The pattern uses special characters:
             # 0 matches all digits
             # # matches all digits except the leading zeros
             # . matches a decimal separator
             # E separates mantissa and exponent in scientific notation.
           </xsd:documentation>
         </xsd:annotation>
       </xsd:element>
       <xsd:element name="dateFormat" type="sdf:dateFormat">
         <xsd:annotation>
           <xsd:documentation xml:lang="en">
            This nodes allow to specify a pattern for date and time.
            Warning: this node is only supported in writing mode!
           </xsd:documentation>
         </xsd:annotation>
       </xsd:element>
       <xsd:element name="byteOrder" type="sdf:byteOrder" default="MSB">
         <xsd:annotation>
           <xsd:documentation xml:lang="en">
            SDF handles two binary encoding for integers.
            # Most Significant Byte first (MSB)
            # Less Significant Byte first (LSB)

            Most Significant Byte (MSB) ordering:
            The Most Significant Byte encoding (MSB) also known as big-endian
            writes the bytes from left to right.
            For example, the hexadecimal number 0x1ED8 (e.g. 7896) encoded as a
            short (2-bytes integer) is written 1E D8.

            Less Significant Byte (LSB) ordering:
            The Less Significant Byte encoding (LSB) also known as little-endian
            writes the bytes from right to left.
            For example, the hexadecimal number 0x03E03F38 (e.g. 65027896)
            encoded as an int (4-bytes integer) is written in reverse order
            38 3F E0 03.

            Note: Binary integer have a MSB representation by default.
           </xsd:documentation>
         </xsd:annotation>
       </xsd:element>
       <xsd:element name="delimiter" type="sdf:delimiter">
         <xsd:annotation>
           <xsd:documentation xml:lang="en">
            This node define the separator character between two or more
            elements. The default delimiter is a space character for ASCII
            encoding and empty for BINARY encoding.
           </xsd:documentation>
         </xsd:annotation>
       </xsd:element>
       <xsd:element name="signature" type="sdf:signature">
         <xsd:annotation>
           <xsd:documentation xml:lang="en">
            This node allows to select an element depending on its content.
            This node is necessary to handle elements with a variable
            content (choice group, type derivation, substitution group).
            In that case, the SDF engine will select the first substitution
            with a valid signature.
           </xsd:documentation>
         </xsd:annotation>
       </xsd:element>
       <!--
       <xsd:element name="value" type="sdf:value">
         <xsd:annotation>
           <xsd:documentation xml:lang="en">
           Warning: not implemented!
           </xsd:documentation>
         </xsd:annotation>
       </xsd:element>
       -->
       <xsd:element name="array" type="sdf:array">
         <xsd:annotation>
           <xsd:documentation xml:lang="en">
            When the datatype of an element is xs:list, it is possible to set
            the attributes relying to array item by using an sdf:array node.
            The supported children are the following:
            # occurrence: define the size of the array.
            # length:     define the length of each item in the array.
            # delimiter:  define the separator between each item in the array.
           </xsd:documentation>
         </xsd:annotation>
       </xsd:element>
       <!--
       <xsd:element name="nodeName" type="sdf:nodeName">
         <xsd:annotation>
           <xsd:documentation xml:lang="en">
           Warning: not implemented!
           </xsd:documentation>
         </xsd:annotation>
       </xsd:element>
     -->
     </xsd:choice>

     <xsd:attribute name="query" type="xsd:string" use="optional">
       <xsd:annotation>
         <xsd:documentation xml:lang="en">
         This is an XQuery script that specifies the file containing
         the block data. It corresponds to the base node by default.
         </xsd:documentation>
       </xsd:annotation>
     </xsd:attribute>
   </xsd:complexType>


  <!-- Query properties -->

  <xsd:simpleType name="queryContext">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
       The context node available for query evaluation.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="root"/> 
      <xsd:enumeration value="parent"/> 
      <xsd:enumeration value="self"/> 
    </xsd:restriction>
  </xsd:simpleType>


  <!-- Occurrence count definition -->

  <xsd:complexType name="occurrence">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
      Purpose of this node is to set the occurrence count of the element in the
      Structured Data File. This descriptor is not mandatory and the default
      value is set to 1 if omitted. The Occurrence count of an element can be
      fixed for all datafile using this schema or can depend on the data file
      instance. Therefore you can use this descriptor in two different ways :
      By setting a fixed value or setting a query to process with the file instance.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:extension base="xsd:string"> <!-- Integer or "unbounded" -->
        <xsd:attribute name="query" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            An XQuery script that compute the occurrence value. This is
            usually an XPath but complex expressions are allowed. The result
            shall be an item castable as a long integer (64 bits). In case of
            empty result, the occurrence is set to zero.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="context" type="sdf:queryContext" default="self">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            The context node available for query evaluation.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="constant" type="xsd:boolean" default="true">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            When a query is present, this attribute indicates wether the
            occurrence shall be considered constant. This assumption is true
            by default.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>


  <!-- Length definition -->

  <xsd:complexType name="length">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
      This node is used to set the length of an element. It is mandatory for
      the "leaves" elements because it sets the number of bytes to be read to
      access the data in the file. For complex elements and types, it is not
      recommended to set the length (unless you want to force the value)
      because it will result from the sum of all child lengths, paddings, etc. 
      Length value can be defined in bytes or in bits. A "unit" attribute can
      be added to set "byte" or "bit" unit. If the "unit" attribute is ommited,
      the "byte" unit is set by default. In case of "bit" unit the length
      cannot be longer than 32 in this version. As the occurrence count the
      length can be set to a fixed value or using query.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:extension base="xsd:string"> <!-- Long or "unbounded" -->
        <xsd:attribute name="query" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            An XQuery script that computes the length value. This is usually
            an XPath but complex expressions are allowed. The result shall be
            an item castable as a unsigned long integer (64 bits). In case of
            empty result, the length is set to zero.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="context" type="sdf:queryContext" default="self">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            The context node available for query evaluation.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="constant" type="xsd:boolean" default="true">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            When a query is present, this attribute indicates wether the block
            length shall be considered constant. This assumption is true by
            default.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="unit" type="lengthUnit" default="byte">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            The unit of the length value.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>


  <xsd:simpleType name="lengthUnit">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
        The unit available for length definition are byte and bit.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="byte"/> 
      <xsd:enumeration value="bit"/> 
    </xsd:restriction>
  </xsd:simpleType>


  <!-- Offset definition -->

  <xsd:complexType name="offset">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
      Purpose of this node is to set the offset of an element.  This means a
      shift between the last byte of the last occurrence of the previous
      element or the parent element and the first byte of the current one (case
      of relative offset). In most cases, an element is following its previous
      sibling without any gap therefore no relative offset is needed. If the
      "sdf:offset" node is omitted, the value is set to 0 by default.
      Note: In order to read the data at the right offset in the file, the
      absolute offset is computed from previous element structures such as
      occurrence counts, lengths and relative offsets.
      Note: Offset value can be defined in bytes or in bits. A "unit" attribute
      can be added to set "byte" or "bit" unit. If the "unit" attribute is
      ommited, the "byte" unit is set by default.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:extension base="xsd:integer"> <!-- Long -->
        <xsd:attribute name="query" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            An XQuery script that computes the offset value. This is usually an
            XPath but complex expressions are allowed. The result shall be a
            single item castable as a unsigned long integer (64 bits). In case
            of empty result, the offset is set to zero.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="context" type="sdf:queryContext" default="self">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            The context node available for query evaluation.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="constant" type="xsd:boolean" default="true">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            A boolean indicating if the query is evaluated for each occurrence.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="unit" type="lengthUnit" default="byte">
           <xsd:annotation>
             <xsd:documentation xml:lang="en">
              The unit of the offset value.
             </xsd:documentation>
           </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="origin" type="offsetOrigin" default="previous">
           <xsd:annotation>
             <xsd:documentation xml:lang="en">
              The origin is the start position used to compute the offset.
              It is located at the end position of the previous block, by default.
              SDF can compute the absolute position in the file from a
              user-defined origin:
              # previous - the offset is relative to the previous-sibling node.
              # parent   - the offset is relative to the parent node.
              # root     - the offset is absolute (e.g. from the beginning of the
                           file)
             </xsd:documentation>
           </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>

  <xsd:simpleType name="offsetOrigin">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
      The origin is the start position used to compute the offset. It is
      located at the end position of the previous block, by default. SDF can
      compute the absolute position in the file from a user-defined origin:
      # previous - the offset is relative to the previous-sibling node.
      # parent   - the offset is relative to the parent node.
      # root     - the offset is absolute (e.g. from the beginning of the file)
      </xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="previous"/> 
      <xsd:enumeration value="parent"/> 
      <xsd:enumeration value="root"/> 
    </xsd:restriction>
  </xsd:simpleType>


  <!-- Encoding definition -->

  <xsd:simpleType name="encoding">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
      In a logical representation the encoding is not needed but in a physical
      representation you need to know how to extract the data from the file.
      Therefore this node is used to set the encoding method of the element. If
      the "sdf:encoding" node is omitted the encoding is inherited from the
      parent. The root element has a BINARY encoding by default.
      Possible values are: "ASCII", "BINARY", "EBCDIC".
      Warning: the "EBCDIC" is only supported in reading mode!
      Note: Encoding method is also important to get values from numeric
      elements. In case of float a BINARY encoding means the IEEE-754
      representation is used to extract the value.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="ASCII"/>
      <xsd:enumeration value="BINARY"/>
      <xsd:enumeration value="EBCDIC"/>
    </xsd:restriction>
  </xsd:simpleType>


  <!-- Padding definition -->

  <xsd:complexType name="padding">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
      This node defines a gap (offset) before or after an element. The length
      of this gap is express as a xsd:nonNegativeInteger (in number of bytes).
      Two types are available: the "header" padding and the "footer" padding.
      They can be set together or only one of them.
      The padding has ASCII or Binary encoding:
      # "content" - fills the padding with a string value
      # "code"    - fills the padding with a single byte value
      These two attributes can not be present at the same time.  If the
      "sdf:padding" node is omitted the value is set to 0 by default.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:extension base="xsd:nonNegativeInteger">
        <xsd:attribute name="type" type="paddingType" use="required">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            Can be one of: "header", "footer", "leading", "trailing".
            Warning: "leading", "trailing" are not implemented yet!
            # "header" - the padding is before the element
            # "footer" - the padding is after the element
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="content" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            The textual content of the padding.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="code" type="xsd:int" use="optional">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            A single char code.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>


  <xsd:simpleType name="paddingType">
     <xsd:annotation>
        <xsd:documentation xml:lang="en">
         The location available for padding insertion are header and footer.
        </xsd:documentation>
     </xsd:annotation>
     <xsd:restriction base="xsd:string">
        <xsd:enumeration value="header"/>
        <xsd:enumeration value="footer"/>
        <xsd:enumeration value="leading"/>
        <xsd:enumeration value="trailing"/>
     </xsd:restriction>
  </xsd:simpleType>


  <!-- numericFormat definition -->

  <xsd:complexType name="numericFormat">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
      Purpose of the sdf:numericFormat node is to set the lexical
      representation of a numeric value. It controls the following features:
       # integer digits
       # fraction digits
       # exponent digits
       # prefix
       # suffix
      The pattern uses special characters:
       # 0 matches all digits
       # # matches all digits except the leading zeros
       # . matches a decimal separator
       # E separates mantissa and exponent in scientific notation.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:sequence>
      <!--
      <xsd:element name="integerDigits" type="sdf:numericFormatDigits"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">
          Warning: this node support is not yet implemented!
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="fractionDigits" type="sdf:numericFormatDigits"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">
          Warning: this node support is not yet implemented!
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      -->
    </xsd:sequence>

    <xsd:attribute name="pattern" type="xsd:string">
      <xsd:annotation>
        <xsd:documentation xml:lang="en"
                           source="http://java.sun.com/j2se/1.5.0/docs/api/java/text/DecimalFormat.html">
           patterns have the following syntax:

              Pattern:
                      PositivePattern
                      PositivePattern ; NegativePattern
              PositivePattern:
                      Prefixopt Number Suffixopt
              NegativePattern:
                      Prefixopt Number Suffixopt
              Prefix:
                      any Unicode characters except \uFFFE, \uFFFF, and special
                      characters
              Suffix:
                      any Unicode characters except \uFFFE, \uFFFF, and special
                      characters
              Number:
                      Integer Exponentopt
                      Integer . Fraction Exponentopt
              Integer:
                      MinimumInteger
                      #
                      # Integer
                      # , Integer
              MinimumInteger:
                      0
                      0 MinimumInteger
                      0 , MinimumInteger
              Fraction:
                      MinimumFractionopt OptionalFractionopt
              MinimumFraction:
                      0 MinimumFractionopt
              OptionalFraction:
                      # OptionalFractionopt
              Exponent:
                      E MinimumExponent
              MinimumExponent:
                      0 MinimumExponentopt
              

           Special Pattern Characters

           Many characters in a pattern are taken literally; they are matched
           during parsing and output unchanged during formatting. Special
           characters, on the other hand, stand for other characters, strings,
           or classes of characters. They must be quoted, unless noted
           otherwise, if they are to appear in the prefix or suffix as literals.

           Symbol    Location    Localized?  Meaning
           0   Number   Yes   Digit
           #   Number   Yes   Digit, zero shows as absent
           .   Number   Yes   Decimal separator or monetary decimal separator
           -   Number   Yes   Minus sign
           ,   Number   Yes   Grouping separator
           E   Number   Yes   Separates mantissa and exponent in scientific
                              notation. Need not be quoted in prefix or suffix.
           ;   Subpattern boundary  Yes   Separates positive and negative
                                          subpatterns
           %   Prefix or suffix  Yes   Multiply by 100 and show as percentage
           \u2030    Prefix or suffix  Yes   Multiply by 1000 and show as per
                                             mille value
           (\u00A4)   Prefix or suffix  No    Currency sign, replaced by
                                                currency symbol. If doubled,
                                                replaced by international
                                                currency symbol. If present in a
                                                pattern, the monetary decimal
                                                separator is used instead of the
                                                decimal separator.
           '   Prefix or suffix  No    Used to quote special characters in a
                                       prefix or suffix, for example, "'#'#"
                                       formats 123 to "#123". To create a single
                                       quote itself, use two in a row:
                                       "# o''clock".
        </xsd:documentation>
      </xsd:annotation>
    </xsd:attribute>
  </xsd:complexType>

  <!-- Not implemented yet
  <xsd:complexType name="numericFormatDigits">
    <xsd:simpleContent>
      <xsd:extension base="xsd:nonNegativeInteger">
        <xsd:attribute name="min" type="xsd:nonNegativeInteger">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="max" type="xsd:nonNegativeInteger">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>
  -->


  <!-- dateFormat definition -->

  <xsd:complexType name="dateFormat">
     <xsd:annotation>
       <xsd:documentation xml:lang="en">
        This nodes allow to specify a pattern for date and time.
        Warning: this node is only supported in writing mode!
       </xsd:documentation>
     </xsd:annotation>
     <xsd:attribute name="pattern" type="xsd:string">
       <xsd:annotation>
         <xsd:documentation xml:lang="en"
                            source="http://java.sun.com/j2se/1.5.0/docs/api/java/text/SimpleDateFormat.html">
            Date and Time Patterns
   
            Date and time formats are specified by date and time pattern
            strings. Within date and time pattern strings, unquoted letters
            from 'A' to 'Z' and from 'a' to 'z' are interpreted as pattern
            letters representing the components of a date or time string. Text
            can be quoted using single quotes (') to avoid interpretation.
            "''" represents a single quote. All other characters are not
            interpreted; they're simply copied into the output string during
            formatting or matched against the input string during parsing.
            The following pattern letters are defined (all other characters from
            'A' to 'Z' and from 'a' to 'z' are reserved):
   
                Letter  Date or Time Component  Presentation   Examples
                G    Era designator    Text  AD
                y    Year  Year  1996; 96
                M    Month in year  Month    July; Jul; 07
                w    Week in year   Number   27
                W    Week in month  Number   2
                D    Day in year    Number   189
                d    Day in month   Number   10
                F    Day of week in month    Number   2
                E    Day in week    Text  Tuesday; Tue
                a    Am/pm marker   Text  PM
                H    Hour in day (0-23)   Number   0
                k    Hour in day (1-24)   Number   24
                K    Hour in am/pm (0-11)    Number   0
                h    Hour in am/pm (1-12)    Number   12
                m    Minute in hour    Number   30
                s    Second in minute  Number   55
                S    Millisecond    Number   978
                z    Time zone   General time zone    Pacific Standard Time;
                                                      PST; GMT-08:00
                Z    Time zone   RFC 822 time zone    -0800
   
            Pattern letters are usually repeated, as their number determines the
            exact presentation: 
                * Text: For formatting, if the number of pattern letters is 4
                    or more, the full form is used; otherwise a short or
                    abbreviated form is used if available. For parsing, both
                    forms are accepted, independent of the number of pattern
                    letters.
                * Number: For formatting, the number of pattern letters is the
                    minimum number of digits, and shorter numbers are
                    zero-padded to this amount. For parsing, the number of
                    pattern letters is ignored unless it's needed to separate
                    two adjacent fields.
                * Year: For formatting, if the number of pattern letters is 2,
                    the year is truncated to 2 digits; otherwise it is
                    interpreted as a number.

                    For parsing, if the number of pattern letters is more than
                    2, the year is interpreted literally, regardless of the
                    number of digits. So using the pattern "MM/dd/yyyy",
                    "01/11/12" parses to Jan 11, 12 A.D.
                    For parsing with the abbreviated year pattern ("y" or "yy"),
                    SimpleDateFormat must interpret the abbreviated year
                    relative to some century.
                    It does this by adjusting dates to be within 80 years before
                    and 20 years after the time the SimpleDateFormat instance is
                    created. For example, using a pattern of "MM/dd/yy" and a
                    SimpleDateFormat instance created on Jan 1, 1997, the
                    string "01/11/12" would be interpreted as Jan 11, 2012
                    while the string "05/04/64" would be interpreted as May 4,
                    1964. During parsing, only strings consisting of exactly two
                    digits, as defined by Character.isDigit(char), will be
                    parsed into the default century. Any other numeric string,
                    such as a one digit string, a three or more digit string, or
                    a two digit string that isn't all digits
                    (for example, "-1"), is interpreted literally. So "01/02/3"
                    or "01/02/003" are parsed, using the same pattern,
                    as Jan 2, 3 AD. Likewise, "01/02/-3" is parsed as
                    Jan 2, 4 BC.
                * Month: If the number of pattern letters is 3 or more, the
                    month is interpreted as text; otherwise, it is interpreted
                    as a number.
                * General time zone: Time zones are interpreted as text if they
                    have names. For time zones representing a GMT offset value,
                    the following syntax is used:
   
                       GMTOffsetTimeZone:
                               GMT Sign Hours : Minutes
                       Sign: one of
                               + -
                       Hours:
                               Digit
                               Digit Digit
                       Minutes:
                               Digit Digit
                       Digit: one of
                               0 1 2 3 4 5 6 7 8 9
   
                    Hours must be between 0 and 23, and Minutes must be between
                    00 and 59. The format is locale independent and digits must
                    be taken from the Basic Latin block of the Unicode standard.

                    For parsing, RFC 822 time zones are also accepted.
                * RFC 822 time zone: For formatting, the RFC 822 4-digit time
                    zone format is used:
   
                       RFC822TimeZone:
                               Sign TwoDigitHours Minutes
                       TwoDigitHours:
                               Digit Digit

                    TwoDigitHours must be between 00 and 23. Other definitions
                    are as for general time zones.

                    For parsing, general time zones are also accepted. 
         </xsd:documentation>
       </xsd:annotation>
     </xsd:attribute>
  </xsd:complexType>


  <!-- byteOrder definition -->

  <xsd:simpleType name="byteOrder">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
      SDF handles two binary encoding for integers:
      # Most Significant Byte first (MSB);
      # Less Significant Byte first (LSB).
      Most Significant Byte (MSB) ordering:
      The Most Significant Byte encoding (MSB) also known as big-endian writes
      the bytes from left to right. For example, the hexadecimal number 0x1ED8
      (e.g. 7896) encoded as a short (2-bytes integer) is written 1E D8. Less
      Significant Byte (LSB) ordering: The Less Significant Byte encoding (LSB)
      also known as little-endian writes the bytes from right to left. For
      example, the hexadecimal number 0x03E03F38 (e.g. 65027896) encoded as an
      int (4-bytes integer) is written in reverse order 38 3F E0 03.
      Note: Binary integer have a MSB representation by default.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:enumeration value="LSB"/> 
      <xsd:enumeration value="MSB"/> 
    </xsd:restriction>
  </xsd:simpleType>


  <!-- Delimiter definition -->

  <xsd:complexType name="delimiter">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
      This node define the separator character between two or more elements (or
      between each item in an array). The default delimiter is a space
      character for ASCII encoding and empty for BINARY encoding.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:extension base="sdf:delimiterContent">
        <xsd:attribute name="value" type="sdf:delimiterContent"
                       use="optional">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            Specifies the delimiter as a character value.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="code" type="xsd:short">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            Specifies the delimiter as a byte value.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>

  <xsd:simpleType name="delimiterContent">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
      The separator character between two or more elements (or between each
      item in an array). The default delimiter is a space character for ASCII
      encoding and empty for BINARY encoding.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:restriction base="xsd:string">
      <xsd:length value="1"/>
    </xsd:restriction>
  </xsd:simpleType>


  <!-- Signature definition -->

  <xsd:complexType name="signature">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
      This node allows to select an element depending on its content.
      This node is necessary to handle elements with a variable
      content (choice group, type derivation, substitution group).
      In that case, the SDF engine will select the first substitution
      with a valid signature.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:simpleContent>
      <xsd:extension base="xsd:string">
        <xsd:attribute name="query" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            An XQuery script that computes the boolean value of the
            sdf:signature.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="value" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            Specifies the expected string value of the element. The sdf:signature
            is true if the element value matches this value attribute.  
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>


  <!-- value definition -->

  <!-- Not implemented
  <xsd:simpleType name="value">
    <xsd:restriction base="xsd:string">
    </xsd:restriction>
  </xsd:simpleType>
  -->


  <!-- Array definition -->

  <xsd:complexType name="array">
    <xsd:annotation>
      <xsd:documentation xml:lang="en">
      When the datatype of an element is xs:list, it is possible to set the
      attributes relying to array item by using an sdf:array node.  The
      supported children are the following:
      # occurrence: define the size of the array.
      # length:     define the length of each item in the array.
      # delimiter:  define the separator between each item in the array.
      </xsd:documentation>
    </xsd:annotation>
    <xsd:all>
      <xsd:element name="occurrence" type="sdf:occurrence"
                   default="unbounded" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">
           Define the size of the array.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="length" type="sdf:length"
                   default="unbounded" minOccurs="0">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">
           Define the length of each item in the array.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
      <xsd:element name="delimiter" type="sdf:delimiter"
                   minOccurs="0">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">
           Define the separator between each item in the array.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:element>
    </xsd:all>
  </xsd:complexType>


  <!-- nodeName definition-->

  <!-- Not implemented
  <xsd:complexType name="nodeName">
    <xsd:simpleContent>
      <xsd:extension base="xsd:string">
        <xsd:attribute name="query" type="xsd:string" use="optional">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="context" type="sdf:queryContext" default="self">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            The context node available for query evaluation.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
        <xsd:attribute name="constant" type="xsd:boolean" default="true">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            </xsd:documentation>
          </xsd:annotation>
        </xsd:attribute>
      </xsd:extension>
    </xsd:simpleContent>
  </xsd:complexType>
-->

   <!-- View definition -->
   <xsd:complexType name="view">
     <xsd:annotation>
       <xsd:documentation xml:lang="en">
         Defines virtual element that is computed either from an XQuery script
         or a fixed string value.
       </xsd:documentation>
     </xsd:annotation>
      <xsd:choice minOccurs="0" maxOccurs="unbounded">
        <xsd:element name="query" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            The XQuery script that transform the context node defined with
            the sdf:base attribute.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
        <xsd:element name="value" type="xsd:string">
          <xsd:annotation>
            <xsd:documentation xml:lang="en">
            A string value that specifies the content of the element.
            </xsd:documentation>
          </xsd:annotation>
        </xsd:element>
      </xsd:choice>
 
      <xsd:attribute name="base" type="xsd:string" use="required">
        <xsd:annotation>
          <xsd:documentation xml:lang="en">
          The sdf schema definition of the context node read from the sdf source.
          </xsd:documentation>
        </xsd:annotation>
      </xsd:attribute>
   </xsd:complexType>

</xsd:schema>
